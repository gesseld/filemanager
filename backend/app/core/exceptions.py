"""RFC 7807 compliant error handling."""

from typing import Any, Dict, Optional, Union
from fastapi import HTTPException, Request, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from loguru import logger


class ProblemDetail(BaseModel):
    """RFC 7807 Problem Details for HTTP APIs."""
    
    type: str = Field(
        default="about:blank",
        description="A URI reference that identifies the problem type"
    )
    title: str = Field(
        description="A short, human-readable summary of the problem type"
    )
    status: int = Field(
        description="The HTTP status code generated by the origin server"
    )
    detail: Optional[str] = Field(
        default=None,
        description="A human-readable explanation specific to this occurrence"
    )
    instance: Optional[str] = Field(
        default=None,
        description="A URI reference that identifies the specific occurrence"
    )
    
    class Config:
        """Pydantic configuration."""
        extra = "allow"


class ErrorResponse(ProblemDetail):
    """Extended error response with additional context."""
    
    request_id: Optional[str] = None
    timestamp: Optional[str] = None
    
    def model_dump(self, **kwargs) -> Dict[str, Any]:
        """Convert to dictionary with RFC 7807 compliance."""
        data = super().model_dump(**kwargs)
        
        # Remove None values
        return {k: v for k, v in data.items() if v is not None}


class FileManagerException(HTTPException):
    """Base exception for file manager application."""
    
    def __init__(
        self,
        status_code: int,
        detail: str,
        headers: Optional[Dict[str, str]] = None,
        type_uri: str = "about:blank",
        title: Optional[str] = None
    ):
        """Initialize exception."""
        super().__init__(status_code=status_code, detail=detail, headers=headers)
        self.type_uri = type_uri
        self.title = title or self._get_default_title(status_code)
    
    @staticmethod
    def _get_default_title(status_code: int) -> str:
        """Get default title for status code."""
        titles = {
            400: "Bad Request",
            401: "Unauthorized",
            403: "Forbidden",
            404: "Not Found",
            409: "Conflict",
            422: "Unprocessable Entity",
            500: "Internal Server Error",
        }
        return titles.get(status_code, "Unknown Error")


class ValidationException(FileManagerException):
    """Validation exception."""
    
    def __init__(self, detail: str, headers: Optional[Dict[str, str]] = None):
        """Initialize validation exception."""
        super().__init__(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=detail,
            headers=headers,
            type_uri="https://tools.ietf.org/html/rfc7231#section-6.5.1",
            title="Validation Error"
        )


class NotFoundException(FileManagerException):
    """Resource not found exception."""
    
    def __init__(self, detail: str, headers: Optional[Dict[str, str]] = None):
        """Initialize not found exception."""
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail,
            headers=headers,
            type_uri="https://tools.ietf.org/html/rfc7231#section-6.5.4",
            title="Resource Not Found"
        )


class ConflictException(FileManagerException):
    """Resource conflict exception."""
    
    def __init__(self, detail: str, headers: Optional[Dict[str, str]] = None):
        """Initialize conflict exception."""
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail,
            headers=headers,
            type_uri="https://tools.ietf.org/html/rfc7231#section-6.5.8",
            title="Resource Conflict"
        )


class UnauthorizedException(FileManagerException):
    """Unauthorized access exception."""
    
    def __init__(self, detail: str, headers: Optional[Dict[str, str]] = None):
        """Initialize unauthorized exception."""
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            headers=headers,
            type_uri="https://tools.ietf.org/html/rfc7235#section-3.1",
            title="Unauthorized"
        )


class ForbiddenException(FileManagerException):
    """Forbidden access exception."""
    
    def __init__(self, detail: str, headers: Optional[Dict[str, str]] = None):
        """Initialize forbidden exception."""
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail,
            headers=headers,
            type_uri="https://tools.ietf.org/html/rfc7231#section-6.5.3",
            title="Forbidden"
        )


async def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:
    """Handle HTTP exceptions with RFC 7807 format."""
    from datetime import datetime, timezone
    
    # Get request ID from context if available
    request_id = None
    try:
        from starlette_context import context
        request_id = context.data.get("request_id")
    except ImportError:
        pass
    
    # Create problem detail
    problem_detail = ErrorResponse(
        type=getattr(exc, "type_uri", "about:blank"),
        title=getattr(exc, "title", exc.detail),
        status=exc.status_code,
        detail=exc.detail,
        instance=str(request.url),
        request_id=request_id,
        timestamp=datetime.now(timezone.utc).isoformat()
    )
    
    # Log the error
    logger.error(
        f"HTTP {exc.status_code}: {exc.detail}",
        extra={
            "request_id": request_id,
            "method": request.method,
            "url": str(request.url),
            "status_code": exc.status_code,
            "detail": exc.detail
        }
    )
    
    return JSONResponse(
        status_code=exc.status_code,
        content=problem_detail.model_dump(),
        headers=exc.headers
    )


async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Handle unhandled exceptions with RFC 7807 format."""
    from datetime import datetime, timezone
    
    # Get request ID from context if available
    request_id = None
    try:
        from starlette_context import context
        request_id = context.data.get("request_id")
    except ImportError:
        pass
    
    # Log the error
    logger.exception(
        f"Unhandled exception: {str(exc)}",
        extra={
            "request_id": request_id,
            "method": request.method,
            "url": str(request.url),
            "exception": str(exc),
            "exception_type": type(exc).__name__
        }
    )
    
    # Create problem detail
    problem_detail = ErrorResponse(
        type="about:blank",
        title="Internal Server Error",
        status=500,
        detail="An unexpected error occurred. Please try again later.",
        instance=str(request.url),
        request_id=request_id,
        timestamp=datetime.now(timezone.utc).isoformat()
    )
    
    return JSONResponse(
        status_code=500,
        content=problem_detail.model_dump()
    )


def register_exception_handlers(app) -> None:
    """Register exception handlers with the FastAPI app."""
    app.add_exception_handler(HTTPException, http_exception_handler)
    app.add_exception_handler(Exception, general_exception_handler)